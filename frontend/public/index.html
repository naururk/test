// server.js
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import path from "path";
import fs from "fs";
import os from "os";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// === ENV ===
dotenv.config({ path: path.resolve(__dirname, ".env") });
const PORT = Number(process.env.PORT || 3046);
const HOST = process.env.HOST || "0.0.0.0";

// Upstreams
const RELAYER_UPSTREAM = process.env.RELAYER_UPSTREAM || "https://relayer.testnet.zama.org";
const GATEWAY_UPSTREAM = process.env.GATEWAY_UPSTREAM || "https://gateway.testnet.zama.org";

// === PATHS ===
const publicDir = path.join(__dirname, "frontend", "public");
const indexHtmlPath = path.join(publicDir, "index.html");
if (!fs.existsSync(indexHtmlPath)) {
  throw new Error(`index.html not found at ${indexHtmlPath}`);
}
console.log("[DEBUG] index.html found at:", indexHtmlPath);

// === APP ===
const app = express();

// Ð’Ð°Ð¶Ð½Ð¾: ÐµÑÐ»Ð¸ Ð²Ð´Ñ€ÑƒÐ³ Ñƒ Ñ‚ÐµÐ±Ñ ÑÑ‚Ð¾Ð¸Ñ‚ compression() Ð³Ð´Ðµ-Ñ‚Ð¾ â€” Ð£Ð‘Ð•Ð Ð˜ ÐµÐ³Ð¾.
// ÐÐ°Ð¼ Ð½ÐµÐ»ÑŒÐ·Ñ â€œÐ¸Ð³Ñ€Ð°Ñ‚ÑŒÑÑâ€ Ñ Content-Encoding Ð½Ð° ÑÑ‚Ð¸Ñ… Ñ€Ð¾ÑƒÑ‚Ð¸Ð½Ð³Ð°Ñ….

app.use(cors());

// COOP/COEP Ð½ÑƒÐ¶Ð½Ñ‹ Ð´Ð»Ñ Relayer SDK (SharedArrayBuffer)
app.use((req, res, next) => {
  res.setHeader("Cross-Origin-Opener-Policy", "same-origin");
  res.setHeader("Cross-Origin-Embedder-Policy", "require-corp");
  next();
});

// Ð§Ñ‚Ð¾Ð±Ñ‹ Ð¿Ñ€Ð¾ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ POST/PUT Ñ Ñ‚ÐµÐ»Ð¾Ð¼
app.use(express.raw({ type: "*/*", limit: "10mb" }));

function getLANAddresses() {
  const ifaces = os.networkInterfaces();
  const addrs = [];
  for (const name of Object.keys(ifaces)) {
    for (const info of ifaces[name] || []) {
      if (info.family === "IPv4" && !info.internal) {
        addrs.push(info.address);
      }
    }
  }
  return addrs;
}

function buildUpstreamUrl(prefix, upstreamBase, originalUrl) {
  // originalUrl includes prefix, e.g. /relayer/v1/keyurl -> /v1/keyurl
  const rest = originalUrl.startsWith(prefix) ? originalUrl.slice(prefix.length) : originalUrl;
  return upstreamBase.replace(/\/+$/, "") + rest;
}

function sanitizeRequestHeaders(req) {
  // Ð—Ð°Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°, Ð½Ð¾ ÑƒÐ±Ð¸Ñ€Ð°ÐµÐ¼ Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ð»Ð¾Ð¼Ð°ÐµÑ‚ Ð¿Ñ€Ð¾ÐºÑÐ¸
  const headers = { ...req.headers };

  delete headers.host;
  delete headers.connection;
  delete headers["content-length"];

  // ÐšÐ»ÑŽÑ‡ÐµÐ²Ð¾Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚: Ð½Ðµ Ð¿Ñ€Ð¾ÑÐ¸Ð¼ ÑÐ¶Ð°Ñ‚Ð¸Ðµ Ñƒ Ð°Ð¿ÑÑ‚Ñ€Ð¸Ð¼Ð°
  headers["accept-encoding"] = "identity";

  // Ð˜Ð½Ð¾Ð³Ð´Ð° Ð¿Ð¾Ð»ÐµÐ·Ð½Ð¾ ÑƒÐ±Ñ€Ð°Ñ‚ÑŒ referer/origin, Ð½Ð¾ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ Ð½Ðµ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾.
  // Ð•ÑÐ»Ð¸ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ â€” Ð¼Ð¾Ð¶Ð½Ð¾ Ñ€Ð°ÑÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ:
  // delete headers.origin;
  // delete headers.referer;

  return headers;
}

function sanitizeResponseHeaders(upHeaders) {
  const headers = {};
  for (const [k, v] of upHeaders.entries()) {
    const key = k.toLowerCase();

    // ÐšÐ»ÑŽÑ‡ÐµÐ²Ð¾Ðµ: ÐÐ• Ð¾Ñ‚Ð´Ð°Ñ‘Ð¼ encoding/length/transfer â€” Ð¸Ð½Ð°Ñ‡Ðµ Ð±ÑƒÐ´ÐµÑ‚ decoding_failed
    if (key === "content-encoding") continue;
    if (key === "content-length") continue;
    if (key === "transfer-encoding") continue;

    // set-cookie Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ Ð½Ðµ Ð½ÑƒÐ¶ÐµÐ½ Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¼ÐµÑˆÐ°Ñ‚ÑŒ (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)
    // if (key === "set-cookie") continue;

    headers[k] = v;
  }
  return headers;
}

async function proxyHandler(prefix, upstreamBase, req, res) {
  try {
    const upstreamUrl = buildUpstreamUrl(prefix, upstreamBase, req.originalUrl);

    const method = req.method.toUpperCase();
    const headers = sanitizeRequestHeaders(req);

    const hasBody = !["GET", "HEAD"].includes(method);
    const body = hasBody ? req.body : undefined;

    const upstreamResp = await fetch(upstreamUrl, {
      method,
      headers,
      body: hasBody ? body : undefined,
      redirect: "follow",
    });

    const outHeaders = sanitizeResponseHeaders(upstreamResp.headers);
    res.status(upstreamResp.status);

    // ÐŸÑ€Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸ (Ð¿Ð¾ÑÐ»Ðµ status)
    for (const [k, v] of Object.entries(outHeaders)) {
      res.setHeader(k, v);
    }

    // Ð˜ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·: Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾ Ð½Ð¸ÐºÐ°ÐºÐ¾Ð³Ð¾ Content-Encoding Ð½Ð°Ñ€ÑƒÐ¶Ñƒ
    res.removeHeader("content-encoding");
    res.removeHeader("Content-Encoding");

    const buf = Buffer.from(await upstreamResp.arrayBuffer());
    res.send(buf);
  } catch (e) {
    console.error("[proxy error]", prefix, e);
    res.status(502).json({ error: "proxy_failed", message: String(e?.message || e) });
  }
}

// --- PROXY ROUTES (Ð’ÐÐ–ÐÐž: Ð´Ð¾ static Ð¸ Ð´Ð¾ SPA fallback) ---
// --- PROXY ROUTES (Ð’ÐÐ–ÐÐž: Ð´Ð¾ static Ð¸ Ð´Ð¾ SPA fallback) ---
app.all(/^\/relayer(\/.*)?$/, (req, res) => proxyHandler("/relayer", RELAYER_UPSTREAM, req, res));
app.all(/^\/gateway(\/.*)?$/, (req, res) => proxyHandler("/gateway", GATEWAY_UPSTREAM, req, res));


// --- STATIC ---
app.use(express.static(publicDir));

// --- SPA FALLBACK (ÐŸÐžÐ¡Ð›Ð•Ð”ÐÐ˜Ðœ!) ---
app.use((req, res) => {
  res.sendFile(indexHtmlPath);
});

// START
app.listen(PORT, HOST, () => {
  const lan = getLANAddresses();
  console.log("ðŸš€ Server is up:");
  console.log(`   Local:   http://localhost:${PORT}/`);
  for (const a of lan) console.log(`   LAN:     http://${a}:${PORT}/`);
  console.log(`   Relayer: ${RELAYER_UPSTREAM}`);
  console.log(`   Gateway: ${GATEWAY_UPSTREAM}`);
  console.log(`   Host:    ${HOST}`);
});
