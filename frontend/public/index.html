<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Proof-of-Education</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light" />

  <!-- Требуется для Relayer SDK (WASM / workers) -->
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin" />
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp" />

  <style>
    :root{
      --bg:#f4f6fb;
      --bg-card:#ffffff;
      --border:#d5ddf0;
      --ink:#0f172a;
      --muted:#6b7280;
      --accent:#2563eb;
      --accent-dark:#1d4ed8;
      --danger:#b91c1c;
      --success:#15803d;
      --shadow:0 18px 40px rgba(15,23,42,.14);
      --r-lg:20px;
      --r-md:12px;
      --pill:#eef2ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0}
    body{
      font:15px/1.5 system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
      background:
        radial-gradient(1200px 600px at 50% -10%, #dbeafe 0, transparent 60%),
        linear-gradient(180deg,#e5e7eb 0,#f9fafb 40%,#eef2ff 100%);
      color:var(--ink);
      display:flex;
      flex-direction:column;
      align-items:stretch;
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 16px;
      gap:10px;
      border-bottom:1px solid #e5e7eb;
      backdrop-filter:blur(10px);
      background:rgba(255,255,255,.85);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .logo{
      width:32px;height:32px;border-radius:16px;
      background:conic-gradient(from 150deg,#4f46e5,#22c55e,#38bdf8,#4f46e5);
      display:flex;align-items:center;justify-content:center;
      color:#eef2ff;font-weight:900;font-size:16px;
      box-shadow:0 12px 25px rgba(79,70,229,.4);
    }
    .brand-main{font-weight:800;font-size:18px}
    .brand-sub{font-size:12px;color:var(--muted)}
    .top-right{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .pill{
      display:inline-flex;align-items:center;gap:6px;
      padding:5px 10px;border-radius:999px;
      border:1px solid #e5e7eb;background:#fff;
      font-size:12px;color:var(--muted);
    }
    .pill strong{color:var(--ink);font-weight:600}
    .mono{font-family:ui-monospace,Menlo,Consolas,"SF Mono",monospace}

    .btn{
      appearance:none;border:none;cursor:pointer;
      border-radius:999px;
      padding:7px 14px;
      font-size:13px;font-weight:600;
      display:inline-flex;align-items:center;justify-content:center;gap:6px;
      transition:.15s transform ease, .15s box-shadow ease, .15s filter ease, .15s background ease;
    }
    .btn-primary{
      background:linear-gradient(135deg,var(--accent),var(--accent-dark));
      color:#eff6ff;
      box-shadow:0 14px 30px rgba(37,99,235,.40);
    }
    .btn-ghost{
      background:#fff;color:var(--ink);
      border:1px solid #e5e7eb;
    }
    .btn:hover:not(:disabled){transform:translateY(-1px);filter:brightness(1.05)}
    .btn:disabled{opacity:.65;cursor:not-allowed;box-shadow:none;transform:none}

    .layout{
      flex:1;
      display:grid;
      grid-template-columns:minmax(0,1.15fr) minmax(0,1.4fr) minmax(0,1.15fr);
      gap:16px;
      padding:16px;
      max-width:1440px;
      width:100%;
      margin:0 auto 10px;
    }
    .card{
      background:var(--bg-card);
      border-radius:var(--r-lg);
      border:1px solid var(--border);
      box-shadow:var(--shadow);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .card-header{
      display:flex;align-items:center;justify-content:space-between;gap:8px;
    }
    .card-title{font-size:15px;font-weight:700}
    .card-sub{font-size:12px;color:var(--muted)}
    .section-label{
      font-size:11px;color:#9ca3af;text-transform:uppercase;letter-spacing:.16em;
      margin-bottom:4px;
    }

    .field-col{display:flex;flex-direction:column;gap:4px;margin-bottom:6px;}
    .field-label{font-size:13px;font-weight:600;color:#374151}
    .input-shell{
      display:flex;align-items:center;gap:8px;
      border-radius:var(--r-md);
      border:1px solid var(--border);
      padding:8px 10px;
      background:#f9fafb;
    }
    input[type="number"],input[type="text"]{
      border:none;outline:none;background:transparent;
      font:inherit;width:100%;
    }
    input::placeholder{color:#9ca3af}
    .unit{font-size:12px;color:#9ca3af;white-space:nowrap}

    .row{display:flex;gap:10px;align-items:flex-end;flex-wrap:wrap}
    .row-space{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .muted{font-size:12px;color:var(--muted)}
    .status-pill{
      display:inline-flex;align-items:center;gap:6px;
      border-radius:999px;padding:3px 10px;
      border:1px solid #e5e7eb;background:#f9fafb;
      font-size:11px;color:#374151;
    }
    .dot{width:8px;height:8px;border-radius:999px;background:#d1d5db}
    .dot-ok{background:var(--success)}
    .dot-bad{background:var(--danger)}
    .dot-pending{background:#facc15}

    .stamp-row{
      border-radius:var(--r-md);
      border:1px dashed #e5e7eb;
      padding:8px 10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:13px;
      background:#f9fafb;
    }
    .stamp-label{font-weight:500}
    .stamp-value{font-size:12px;color:var(--muted)}
    .stamp-tag{
      border-radius:999px;
      padding:3px 10px;
      font-size:11px;font-weight:600;
      border:1px solid #e5e7eb;
      background:#fff;
    }
    .stamp-tag.ok{border-color:#bbf7d0;background:#dcfce7;color:#166534}
    .stamp-tag.fail{border-color:#fecaca;background:#fee2e2;color:#b91c1c}
    .stamp-tag.pending{border-color:#e5e7eb;background:#f9fafb;color:#6b7280}

    .handle-pill{
      padding:3px 8px;border-radius:999px;
      border:1px dashed #cbd5f5;
      background:#eef2ff;
      font-size:11px;
    }
    .divider{height:1px;background:linear-gradient(90deg,transparent,#e5e7eb,transparent);margin:4px 0 6px}
    .tiny{font-size:11px;color:#9ca3af}

    @media (max-width:1024px){
      .layout{grid-template-columns:minmax(0,1fr);max-width:100%;padding:10px}
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo">E</div>
      <div>
        <div class="brand-main">Proof-of-Education</div>
        <div class="brand-sub">Encrypted modules · public tier stamps (no circles)</div>
      </div>
    </div>
    <div class="top-right">
      <div class="pill">
        Net: <strong class="mono" id="netLabel">—</strong>
      </div>
      <div class="pill">
        Contract: <span class="mono" id="contractShort">—</span>
      </div>
      <div class="pill">
        You: <span class="mono" id="meLabel">not connected</span>
      </div>
      <button id="connectBtn" class="btn btn-primary">Connect wallet</button>
      <button id="resetBtn" class="btn btn-ghost">Reset</button>
    </div>
  </header>

  <main class="layout">
    <!-- LEFT: MODULE STATUS -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Module status</div>
          <div class="card-sub">Tier stamps are public, raw score stays private.</div>
        </div>
        <button id="reloadBtn" class="btn btn-ghost" style="font-size:12px;">Reload</button>
      </div>

      <div class="field-col">
        <div class="field-label">Module ID (u8)</div>
        <div class="input-shell" style="max-width:180px;">
          <input id="moduleIdInput" type="number" min="1" max="255" value="1" />
          <span class="unit">ID</span>
        </div>
      </div>

      <div class="section-label">Stamps</div>

      <div class="stamp-row">
        <div>
          <div class="stamp-label">Stamp A — score ≥ T1</div>
          <div class="stamp-value" id="stampAValue">pending</div>
        </div>
        <div class="stamp-tag pending" id="stampATag">pending</div>
      </div>

      <div class="stamp-row">
        <div>
          <div class="stamp-label">Stamp B — score ≥ T2</div>
          <div class="stamp-value" id="stampBValue">pending</div>
        </div>
        <div class="stamp-tag pending" id="stampBTag">pending</div>
      </div>

      <div class="stamp-row">
        <div>
          <div class="stamp-label">Stamp C — score ≥ T3</div>
          <div class="stamp-value" id="stampCValue">pending</div>
        </div>
        <div class="stamp-tag pending" id="stampCTag">pending</div>
      </div>

      <div class="divider"></div>

      <div class="row-space">
        <div class="field-col" style="margin-bottom:0">
          <div class="field-label">Decision</div>
          <div class="status-pill" id="decisionPill">
            <span class="dot dot-pending" id="decisionDot"></span>
            <span id="decisionText">not computed</span>
          </div>
        </div>
        <div class="field-col" style="margin-bottom:0;text-align:right;">
          <div class="field-label">Tier</div>
          <div class="status-pill">
            <span class="dot dot-pending" id="tierDot"></span>
            <span id="tierText">0</span>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="field-col" style="margin-bottom:0">
        <div class="field-label">Raw score handle</div>
        <div class="row" style="align-items:center;">
          <span class="handle-pill mono" id="scoreHandleLabel">—</span>
        </div>
      </div>

      <div class="row">
        <button id="revealScoreBtn" class="btn btn-ghost">Reveal my score (signed)</button>
        <div class="muted">Your (private) score: <b id="privateScoreText">—</b></div>
      </div>

      <div class="tiny">
        Only the three stamps are public-decryptable via Relayer.  
        In this demo the numeric score is read via signed user decrypt (EIP-712), as in “The Platform”.
      </div>
    </section>

    <!-- CENTER: SUBMIT SCORE -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Submit encrypted score</div>
          <div class="card-sub">Encrypt in browser → contract compares vs encrypted thresholds.</div>
        </div>
      </div>

      <div class="field-col">
        <div class="field-label">Score (uint16)</div>
        <div class="input-shell">
          <input id="scoreInput" type="number" min="0" max="65535" placeholder="e.g. 87" />
          <span class="unit">points</span>
        </div>
      </div>

      <div class="row">
        <button id="submitScoreBtn" class="btn btn-primary">Encrypt &amp; Submit</button>
        <div class="muted" id="submitStatus"></div>
      </div>

      <div class="divider"></div>
      <div class="section-label">Flow</div>
      <div class="muted">
        The Relayer SDK creates an encrypted input for your score.  
        The contract evaluates it fully homomorphically against encrypted thresholds
        and updates your public stamps.
      </div>

      <div class="divider"></div>
      <div class="section-label">SDK / CORS</div>
      <div class="tiny" id="sdkHint">
        If the SDK fails to load, check VPN/firewall and that at least one CDN is reachable:
        <code>cdn.zama.org</code>, <code>cdn.jsdelivr.net</code>, <code>unpkg.com</code>.
      </div>
    </section>

    <!-- RIGHT: ADMIN -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Admin · encrypted thresholds</div>
          <div class="card-sub">Owner-only: thresholds remain encrypted on-chain.</div>
        </div>
      </div>

      <div class="section-label">Thresholds for current module</div>

      <div class="field-col">
        <div class="field-label">T1 (uint16)</div>
        <div class="input-shell">
          <input id="t1Input" type="number" min="0" max="65535" value="50" />
          <span class="unit">points</span>
        </div>
      </div>
      <div class="field-col">
        <div class="field-label">T2 (uint16)</div>
        <div class="input-shell">
          <input id="t2Input" type="number" min="0" max="65535" value="120" />
          <span class="unit">points</span>
        </div>
      </div>
      <div class="field-col">
        <div class="field-label">T3 (uint16)</div>
        <div class="input-shell">
          <input id="t3Input" type="number" min="0" max="65535" value="250" />
          <span class="unit">points</span>
        </div>
      </div>

      <div class="row">
        <button id="setThrBtn" class="btn btn-primary">Encrypt &amp; Update</button>
        <div class="muted" id="thrStatus"></div>
      </div>

      <div class="divider"></div>
      <div class="muted">
        Owner: <span class="mono" id="ownerLabel">—</span>
      </div>
    </section>
  </main>

  <script type="module">
    import { BrowserProvider, Contract } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

    /* ===== CONFIG ===== */
    const CONTRACT_ADDRESS = "0x0A89386172E7E5455b3a3b5f60b1797E04d8C8B0";
    const CHAIN_ID_HEX = "0xaa36a7"; // Sepolia
    const CHAIN_ID_DEC = 11155111n;

    const ORIGIN = window.location.origin;
    const HAS_LOCAL_PROXY = ORIGIN.includes("localhost:3443") || ORIGIN.includes("127.0.0.1:3443");
    const RELAYER_URL = HAS_LOCAL_PROXY ? ORIGIN + "/relayer" : "https://relayer.testnet.zama.org";
    const GATEWAY_URL = HAS_LOCAL_PROXY ? ORIGIN + "/gateway" : "https://gateway.testnet.zama.org";

    const ABI = [
      { inputs:[], name:"owner", outputs:[{type:"address"}], stateMutability:"view", type:"function" },
      { inputs:[{name:"newOwner", type:"address"}], name:"transferOwnership", outputs:[], stateMutability:"nonpayable", type:"function" },

      {
        inputs:[
          {name:"moduleId", type:"uint8"},
          {name:"t1", type:"bytes32"},
          {name:"t2", type:"bytes32"},
          {name:"t3", type:"bytes32"},
          {name:"proof", type:"bytes"},
        ],
        name:"setModuleThresholds", outputs:[], stateMutability:"nonpayable", type:"function"
      },
      {
        inputs:[
          {name:"moduleId", type:"uint8"},
          {name:"encScore", type:"bytes32"},
          {name:"proof", type:"bytes"},
        ],
        name:"submitModuleScore", outputs:[], stateMutability:"nonpayable", type:"function"
      },
      {
        inputs:[{name:"moduleId", type:"uint8"}],
        name:"getMyModuleHandles",
        outputs:[
          {type:"bytes32"}, // score
          {type:"bytes32"}, // pass1
          {type:"bytes32"}, // pass2
          {type:"bytes32"}, // pass3
          {type:"bool"},
        ],
        stateMutability:"view", type:"function"
      },
    ];

    /* ===== RELAYER SDK LOADER (как в The Platform) ===== */
    const CDN_TRIES = [
      "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js",
      "https://cdn.jsdelivr.net/npm/@zama-fhe/relayer-sdk@0.2.0/dist/relayer-sdk-js.js",
      "https://unpkg.com/@zama-fhe/relayer-sdk@0.2.0/dist/relayer-sdk-js.js",
    ];
    async function loadRelayerSdk(){
      let last=null;
      for(const url of CDN_TRIES){
        try{
          console.log("[SDK] trying", url);
          const mod = await import(/* @vite-ignore */ url);
          return mod;
        }catch(e){
          console.warn("[SDK] failed", url, e?.message||e);
          last = e;
        }
      }
      throw last || new Error("Relayer SDK failed to load from all CDNs");
    }

    /* ===== DOM ===== */
    const $ = id => document.getElementById(id);
    const netLabel          = $("netLabel");
    const contractShortEl   = $("contractShort");
    const meLabel           = $("meLabel");
    const connectBtn        = $("connectBtn");
    const resetBtn          = $("resetBtn");
    const reloadBtn         = $("reloadBtn");
    const moduleIdInput     = $("moduleIdInput");

    const stampAValue       = $("stampAValue");
    const stampBValue       = $("stampBValue");
    const stampCValue       = $("stampCValue");
    const stampATag         = $("stampATag");
    const stampBTag         = $("stampBTag");
    const stampCTag         = $("stampCTag");

    const decisionPill      = $("decisionPill");
    const decisionDot       = $("decisionDot");
    const decisionText      = $("decisionText");
    const tierDot           = $("tierDot");
    const tierText          = $("tierText");

    const scoreHandleLabel  = $("scoreHandleLabel");
    const revealScoreBtn    = $("revealScoreBtn");
    const privateScoreText  = $("privateScoreText");

    const scoreInput        = $("scoreInput");
    const submitScoreBtn    = $("submitScoreBtn");
    const submitStatus      = $("submitStatus");

    const sdkHint           = $("sdkHint");

    const t1Input           = $("t1Input");
    const t2Input           = $("t2Input");
    const t3Input           = $("t3Input");
    const setThrBtn         = $("setThrBtn");
    const thrStatus         = $("thrStatus");
    const ownerLabel        = $("ownerLabel");

    contractShortEl.textContent = shortHex(CONTRACT_ADDRESS);

    /* ===== STATE ===== */
    const state = {
      provider:null,
      signer:null,
      contract:null,
      relayer:null,
      sdk:null,
      owner:null,
      lastScoreHandle:null,
      lastStampHandles:[null,null,null],
    };

    function shortHex(addr){
      if(!addr) return "—";
      const s=String(addr);
      if(s.length<=10) return s;
      return s.slice(0,6)+"…"+s.slice(-4);
    }
    function isZeroHandle(h){
      if(!h) return true;
      const s=String(h).toLowerCase();
      return /^0x0{64}$/.test(s);
    }

    /* ===== Helpers: chain & wallet ===== */
    function normalizeChainId(id){
      if(!id) return "";
      const s=String(id);
      if(/^\d+$/.test(s)){ return "0x"+BigInt(s).toString(16); }
      return s.toLowerCase();
    }

    async function ensureSepoliaStrict(){
      if(!window.ethereum?.request) return false;
      let cur = normalizeChainId(await window.ethereum.request({method:"eth_chainId"}).catch(()=>null));
      netLabel.textContent = cur || "unknown";
      if(cur === CHAIN_ID_HEX) return true;

      try{
        await window.ethereum.request({ method:"wallet_switchEthereumChain", params:[{ chainId: CHAIN_ID_HEX }] });
      }catch(e){
        if(e?.code === 4902){
          await window.ethereum.request({
            method:"wallet_addEthereumChain",
            params:[{
              chainId:CHAIN_ID_HEX,
              chainName:"Sepolia",
              nativeCurrency:{ name:"Sepolia ETH", symbol:"SEP", decimals:18 },
              rpcUrls:["https://rpc.sepolia.org"],
              blockExplorerUrls:["https://sepolia.etherscan.io"],
            }],
          });
          await window.ethereum.request({ method:"wallet_switchEthereumChain", params:[{ chainId: CHAIN_ID_HEX }] });
        }else{
          throw e;
        }
      }
      cur = normalizeChainId(await window.ethereum.request({method:"eth_chainId"}).catch(()=>null));
      netLabel.textContent = cur || "unknown";
      return cur === CHAIN_ID_HEX;
    }

    async function connect(){
      if(state.signer){ await disconnect(); return; }
      try{
        if(!window.ethereum?.request){
          alert("Please install MetaMask or another EVM wallet.");
          return;
        }
        await ensureSepoliaStrict();

        const provider = new BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts",[]);
        const signer   = await provider.getSigner();
        const account  = await signer.getAddress();

        const contract = new Contract(CONTRACT_ADDRESS, ABI, signer);

        const sdk = await loadRelayerSdk();
        const { initSDK, createInstance, SepoliaConfig } = sdk;
        if(initSDK) await initSDK();
        const relayer = await createInstance({
          ...SepoliaConfig,
          relayerUrl: RELAYER_URL,
          gatewayUrl: GATEWAY_URL,
          network: window.ethereum,
          debug: true,
        });

        state.provider = provider;
        state.signer   = signer;
        state.contract = contract;
        state.sdk      = sdk;
        state.relayer  = relayer;

        meLabel.textContent = shortHex(account);
        connectBtn.textContent = "Disconnect";
        connectBtn.classList.remove("btn-primary");
        connectBtn.classList.add("btn-ghost");

        try{
          const owner = await contract.owner();
          state.owner = owner;
          ownerLabel.textContent = shortHex(owner);
        }catch{
          ownerLabel.textContent = "—";
        }

        await refreshModule();
      }catch(e){
        console.error(e);
        alert(e?.reason || e?.shortMessage || e?.message || String(e));
      }
    }

    async function disconnect(){
      state.provider=null;
      state.signer=null;
      state.contract=null;
      state.relayer=null;
      state.sdk=null;
      state.owner=null;
      state.lastScoreHandle=null;
      state.lastStampHandles=[null,null,null];

      meLabel.textContent="not connected";
      ownerLabel.textContent="—";
      connectBtn.textContent="Connect wallet";
      connectBtn.classList.add("btn-primary");
      connectBtn.classList.remove("btn-ghost");

      clearModuleUI();
    }

    function clearModuleUI(){
      [stampATag,stampBTag,stampCTag].forEach(el=>{
        el.className="stamp-tag pending"; el.textContent="pending";
      });
      [stampAValue,stampBValue,stampCValue].forEach(el=>{el.textContent="pending";});
      decisionDot.className="dot dot-pending";
      decisionText.textContent="not computed";
      tierDot.className="dot dot-pending";
      tierText.textContent="0";
      scoreHandleLabel.textContent="—";
      privateScoreText.textContent="—";
    }

    /* ===== PUBLIC STAMPS (ONLY publicDecrypt, как в Platform) ===== */
    function boolFromAny(val){
      if(val === null || val === undefined) return null;
      if(typeof val === "boolean") return val;
      if(typeof val === "bigint") return val !== 0n;
      if(typeof val === "number") return val !== 0;
      if(typeof val === "string"){
        const t = val.toLowerCase();
        if(t==="true"||t==="1") return true;
        if(t==="false"||t==="0") return false;
        try{return BigInt(val)!==0n;}catch{return null;}
      }
      if(Array.isArray(val) && val.length) return boolFromAny(val[0]);
      if(typeof val === "object"){
        const vs = Object.values(val);
        if(vs.length) return boolFromAny(vs[0]);
      }
      return null;
    }

    function pickFromDecryptOut(out, handle){
      if(!out || !handle) return null;
      const h = String(handle).toLowerCase();
      const cv = out.clearValues || out.values || out;
      if(cv && typeof cv === "object"){
        const keys = Object.keys(cv);
        const key  = keys.find(k=>k.toLowerCase()===h);
        if(key) return cv[key];
      }
      if(typeof out.abiEncodedClearValues === "string"){
        const hex = out.abiEncodedClearValues.replace(/^0x/,"");
        if(hex.length>=64){
          const word="0x"+hex.slice(0,64);
          try{return BigInt(word);}catch{}
        }
      }
      return null;
    }

    async function decodeStampsWithPublicDecrypt(handles){
      const relayer = state.relayer;
      if(!relayer) throw new Error("Relayer not ready");
      const nonZero = handles.filter(h=>!isZeroHandle(h));
      if(!nonZero.length) return [null,null,null];

      const pairs = nonZero.map(h=>({ handle:String(h), contractAddress:CONTRACT_ADDRESS }));
      const out = await relayer.publicDecrypt(pairs);

      return handles.map(h=>{
        if(isZeroHandle(h)) return null;
        const v = pickFromDecryptOut(out,h);
        return boolFromAny(v);
      });
    }

    /* ===== PRIVATE SCORE (userDecrypt EIP712 — как в The Platform) ===== */
    async function userDecryptScore(handle){
      const relayer = state.relayer;
      const sdk     = state.sdk;
      const signer  = state.signer;
      if(!relayer || !sdk || !signer) throw new Error("Relayer not ready");

      if(isZeroHandle(handle)) throw new Error("No score handle");

      const pair = { handle:String(handle), contractAddress:CONTRACT_ADDRESS };
      const kp = await sdk.generateKeypair();
      const startTs = Math.floor(Date.now()/1000).toString();
      const daysValid = "7";
      const eip = relayer.createEIP712(kp.publicKey,[CONTRACT_ADDRESS],startTs,daysValid);
      const sig = await signer.signTypedData(
        eip.domain,
        { UserDecryptRequestVerification: eip.types.UserDecryptRequestVerification },
        eip.message
      );
      const account = await signer.getAddress();

      const out = await relayer.userDecrypt(
        [pair],
        kp.privateKey,
        kp.publicKey,
        sig.replace("0x",""),
        [CONTRACT_ADDRESS],
        account,
        startTs,
        daysValid
      );

      const key = Object.keys(out||{}).find(k=>k.toLowerCase()===String(handle).toLowerCase());
      if(!key) throw new Error("Empty decrypt result");
      const raw = out[key];

      let bn;
      if(typeof raw==="bigint") bn = raw;
      else if(typeof raw==="number") bn = BigInt(raw);
      else if(typeof raw==="string"){
        bn = raw.startsWith("0x") ? BigInt(raw) : BigInt(raw);
      }else{
        bn = BigInt(String(raw));
      }
      return Number(bn);
    }

    /* ===== MAIN REFRESH ===== */
    async function refreshModule(){
      try{
        if(!state.contract || !state.signer || !state.relayer) return;

        const modId = Number(moduleIdInput.value || "0");
        if(!Number.isInteger(modId) || modId < 1 || modId > 255){
          throw new Error("Module ID must be 1..255");
        }

        const [scoreH, p1, p2, p3, decided] = await state.contract.getMyModuleHandles(modId);
        state.lastScoreHandle = scoreH;
        state.lastStampHandles = [p1,p2,p3];

        scoreHandleLabel.textContent = isZeroHandle(scoreH) ? "—" : shortHex(scoreH);

        if(!decided){
          clearModuleUI();
          return;
        }

        let [b1,b2,b3] = [null,null,null];
        try{
          [b1,b2,b3] = await decodeStampsWithPublicDecrypt([p1,p2,p3]);
        }catch(e){
          console.warn("publicDecrypt failed (CORS?)", e?.message||e);
          sdkHint.textContent = "publicDecrypt failed (likely CORS / gateway). Stamps may stay as 'pending'.";
        }

        function setStamp(tagEl, textEl, b){
          if(b === true){
            tagEl.className="stamp-tag ok"; tagEl.textContent="pass";
            textEl.textContent="pass";
          }else if(b === false){
            tagEl.className="stamp-tag fail"; tagEl.textContent="fail";
            textEl.textContent="fail";
          }else{
            tagEl.className="stamp-tag pending"; tagEl.textContent="pending";
            textEl.textContent="pending";
          }
        }
        setStamp(stampATag, stampAValue, b1);
        setStamp(stampBTag, stampBValue, b2);
        setStamp(stampCTag, stampCValue, b3);

        const tier = [b1,b2,b3].filter(v=>v===true).length;
        tierText.textContent = String(tier);
        tierDot.className = tier>0 ? "dot dot-ok" : "dot dot-pending";
        decisionDot.className = "dot dot-ok";
        decisionText.textContent = "computed";
      }catch(e){
        console.error(e);
        alert(e?.message || "Failed to refresh module state");
      }
    }

    /* ===== ACTIONS ===== */
    async function submitScore(){
      try{
        if(!state.contract || !state.relayer || !state.signer){
          throw new Error("Connect wallet first");
        }
        submitStatus.textContent = "";

        const modId = Number(moduleIdInput.value || "0");
        const raw = scoreInput.value.trim();
        const score = Number(raw);
        if(!Number.isInteger(score) || score < 0 || score > 65535){
          throw new Error("Score must be integer 0..65535");
        }
        if(!Number.isInteger(modId) || modId<1 || modId>255){
          throw new Error("Module ID must be 1..255");
        }

        const sender = await state.signer.getAddress();
        const enc = state.relayer.createEncryptedInput(CONTRACT_ADDRESS, sender);
        enc.add16(score);
        const { handles, inputProof } = await enc.encrypt();

        const tx = await state.contract.submitModuleScore(modId, handles[0], inputProof);
        submitStatus.textContent = "Tx: " + tx.hash.slice(0,10) + "…";
        await tx.wait();
        submitStatus.textContent = "Submitted ✓";
        await refreshModule();
      }catch(e){
        console.error(e);
        submitStatus.textContent = e?.reason || e?.shortMessage || e?.message || String(e);
        alert(submitStatus.textContent);
      }
    }

    async function setThresholds(){
      try{
        if(!state.contract || !state.relayer || !state.signer){
          throw new Error("Connect wallet first");
        }
        thrStatus.textContent = "";

        const modId = Number(moduleIdInput.value || "0");
        const t1 = Number(t1Input.value || "0");
        const t2 = Number(t2Input.value || "0");
        const t3 = Number(t3Input.value || "0");

        for(const [name,val] of [["T1",t1],["T2",t2],["T3",t3]]){
          if(!Number.isInteger(val) || val<0 || val>65535){
            throw new Error(name+" must be integer 0..65535");
          }
        }

        const sender = await state.signer.getAddress();
        const enc = state.relayer.createEncryptedInput(CONTRACT_ADDRESS, sender);
        enc.add16(t1); enc.add16(t2); enc.add16(t3);
        const { handles, inputProof } = await enc.encrypt();

        const tx = await state.contract.setModuleThresholds(modId, handles[0], handles[1], handles[2], inputProof);
        thrStatus.textContent = "Tx: " + tx.hash.slice(0,10) + "…";
        await tx.wait();
        thrStatus.textContent = "Thresholds updated ✓";
        await refreshModule();
      }catch(e){
        console.error(e);
        thrStatus.textContent = e?.reason || e?.shortMessage || e?.message || String(e);
        alert(thrStatus.textContent);
      }
    }

    async function revealScoreSigned(){
      try{
        if(!state.contract || !state.relayer || !state.signer || !state.sdk){
          throw new Error("Connect wallet first");
        }
        const modId = Number(moduleIdInput.value || "0");
        if(!Number.isInteger(modId) || modId < 1 || modId > 255){
          throw new Error("Module ID must be 1..255");
        }

        // всегда берём свежий handle, как в The Platform
        const [scoreH] = await state.contract.getMyModuleHandles(modId);
        state.lastScoreHandle = scoreH;
        scoreHandleLabel.textContent = isZeroHandle(scoreH) ? "—" : shortHex(scoreH);

        const val = await userDecryptScore(scoreH);
        privateScoreText.textContent = String(val);
      }catch(e){
        console.error(e);
        alert(e?.reason || e?.shortMessage || e?.message || String(e));
      }
    }

    /* ===== EVENTS ===== */
    connectBtn.addEventListener("click", connect);
    resetBtn.addEventListener("click", ()=>{ window.location.reload(); });
    reloadBtn.addEventListener("click", ()=>{ refreshModule(); });
    submitScoreBtn.addEventListener("click", submitScore);
    setThrBtn.addEventListener("click", setThresholds);
    revealScoreBtn.addEventListener("click", revealScoreSigned);

    // авто-коннект, если уже авторизован
    if(window.ethereum){
      window.ethereum.on?.("accountsChanged", ()=>window.location.reload());
      window.ethereum.on?.("chainChanged", ()=>window.location.reload());
      (async()=>{
        try{
          const accs = await window.ethereum.request({ method:"eth_accounts" });
          if(Array.isArray(accs) && accs.length){
            await connect();
          }
        }catch{}
      })();
    }
  </script>
</body>
</html>
